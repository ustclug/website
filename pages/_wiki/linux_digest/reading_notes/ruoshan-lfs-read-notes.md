---
---

### 手把手读书报告

来自：黄若山

书在前面的部分可以说是 LFS 的中译版本。如何搭建 Linux 其实就是利用现有的 Linux 系统和 gcc 编译器，编译得到一个不再依赖原有系统的 Linux。这依赖其实最主要的就是 Glibc 了。其实整个过程对我来说，在两次编译 gcc 的过程是最美妙的，其他的就是源码安装软件而已。

所以我就说说我对如何得到全新 gcc 这个过程理解。

glibc 是个独立依赖的库，它只和内核提供的接口有关，不再依赖其他文件。gcc 在编译软件时，可以只使用 glibc 完成编译过程。所以要实现整个新系统的独立，只要用新 gcc 使用新的 glibc。这个过程的实现是先用旧的 glibc 和 gcc（记为 glibc1、gcc1），gcc1+glibc1=gcc2, gcc2+glibc1=glibc2, glibc2+gcc2=gcc3, gcc3+glibc2=最终环境所需要的独立编译环境。(这个过程是否正确我不确定，待我细学后继续……）

在编译那个过程后其实就是自己装软件，最后编译内核，配置相应文件，grub，启动新系统……

我觉得要折腾就折腾前面那部分，然后看看最后的配置文件，比如 rc.conf、udev 等等的就可以了。全部做下来耗时，没什么意义。除非自己作精简系统。

做完这个之后，其实和安装 Gentoo 有点像……

讲讲我看到的一些技巧吧（给新手看的……）：

        - 多核电脑 make 的时候，可以 make -jN(注：N=CPU 核心数目×2+1）1，速度一般要会快很多。
        - 自己编译软件时，可以把目标设成~/.bin/local/***;但是不要把对应的可执行文件目录 export 到 PATH;而是把~/.bin/bin 添加进 PATH，然后把所有可执行文件链接到~/.bin/bin 里面。这和最原始的包管理有点像（书说的）。

书的后半部分除了交叉编译和 hurd 内核和前面的有点相似外，其他的两个部分是 LiveCD 和 USB Live OS 的制作。

对于那两个 Live 系统的制作是很值得一看的，里面见了很多启动的细节，跟在前面编译完目标系统之后。其实在编译目标系统时，基本没什么意思。后面我觉得更有用。后半部分主要讲了 initrd 和 initramfs 的两种辅助系统的启动方式，对于想大致了解下系统是怎么启动的（跳过引导的细节），还是很有帮助的。至少它让你懂得如何问真正关于系统启动的问题了。以后你应该不会直接问“电脑是怎么启动的？”，而是“系统启动内核后是怎么样启动外围设备的？”。这就是好书的作用了，它要么使你完全懂得你想要的所有细节，要么使你学会如何正确有效地提问、搜索。

在后面部分，也捡到了一些小技巧，还是供新手参考的：

1.  如何在一个分区上面同时有两个挂载点？如把 home 和 opt 挂到一个分区

          答案是 Aufs。

    - 把经常用的文件，读写非常非常密集的文件放到 tempfs 上，即先 mount -t tmpfs tmpfs /mnt;cp
    - 用镜像文件保存自己的 home 常用配置。

      - mount -t tmpfs tempfs /mnt
      - dd of=/mnt/home.img if=/dev/zero -bs=10M -count=10
      - mke2fs -t ext3 /mnt/home.img
      - mount -o loop /mnt/home.img /somewhere
      - cp ~/\* /somewhere/

      这样就可以在其他电脑上快速挂载自己的配置，也不用拷贝很多文件了。只要把那个镜像带着就行。
